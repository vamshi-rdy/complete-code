apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
  namespace: production # Added Namespace for isolation
  labels:
    app: nginx
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      serviceAccountName: nginx-service-account # Service Account for running the pod   # Defines the pod's configuration.
      initContainers: # Init container for pre-deployment tasks. Defines an initialization container that runs before the main nginx container starts.
        - name: init-container  
          image: busybox:1.32                                              # Uses busybox:1.32 for running a simple shell command.
          command: ["sh", "-c", "echo 'Initializing nginx pod...'"]        # Runs a shell command to print an initialization message.
          volumeMounts:                                                    # Mounts a volume (config-volume) to /etc/nginx/config in the init container, which could be useful for configuration-related tasks.
            - name: config-volume
              mountPath: /etc/nginx/config
      containers:                                                          # The main containers for the pod.
        - name: nginx                                                      # The container name is nginx.
          image: nginx:1.14.2                                              # Uses the nginx:1.14.2 image.
          ports:                                                           # Exposes port 80 on the container.
            - containerPort: 80
          resources:                                                       # Specifies resource requests and limits for the container.
            requests:                                                      # Minimum resources required for the container (512Mi of memory and 500m CPU).
              memory: "512Mi"
              cpu: "500m"
            limits:                                                        # Maximum resources the container can consume (1Gi of memory and 1 CPU).
              memory: "1Gi"
              cpu: "1"
          livenessProbe:                                                   # A health check to determine if the container is still running and healthy.
            httpGet:                                                       # Sends an HTTP GET request to /healthz on port 80.
              path: /healthz                                               
              port: 80
            initialDelaySeconds: 5                                         # Waits for 5 seconds before starting the probe.
            periodSeconds: 10                                              # Runs the probe every 10 seconds.
          readinessProbe:                                                  # Ensures that the container is ready to serve traffic. Similar to the liveness probe, but used to determine if the container is ready.
            httpGet:
              path: /healthz
              port: 80
            initialDelaySeconds: 5                                        # Waits for 5 seconds before starting the probe.
            periodSeconds: 10                                             # Runs the probe every 10 seconds.
          startupProbe:                                                   # Ensures the container has started successfully before performing liveness or readiness checks.
            httpGet:
              path: /healthz
              port: 80
            initialDelaySeconds: 10                                       # Waits for 10 seconds before starting the probe.
            periodSeconds: 5                                              # Runs the probe every 5 seconds.
      sidecarContainers:                       # Sidecar container for additional functionality (e.g., logging, monitoring) .Adds a sidecar container that runs alongside the main nginx container.
        - name: sidecar-logging       
          image: busybox                                                  # Uses busybox to run a shell command.
          command: ["sh", "-c", "tail -f /var/log/nginx/access.log"]      # Tails the nginx access log in real-time (tail -f).
          volumeMounts:                                                   # Mounts a volume (nginx-log-volume) to /var/log/nginx for accessing logs.
            - name: nginx-log-volume
              mountPath: /var/log/nginx
      volumes:                                                            # Defines volumes to be used by the containers.
        - name: config-volume
          configMap:                                                       # Mounts a ConfigMap called nginx-config to provide the Nginx configuration.
            name: nginx-config
        - name: nginx-log-volume                                           # Uses a Persistent Volume Claim (nginx-pvc) for persistent storage of logs.
          persistentVolumeClaim:
            claimName: nginx-pvc
---
apiVersion: v1                                                    # v1, indicating it's a core Kubernetes API resource.
kind: PersistentVolumeClaim
metadata:                                                         # Defines the nginx-pvc claim in the production namespace.
  name: nginx-pvc
  namespace: production
spec:                                                            # Requests a persistent volume of 1Gi, with access mode ReadWriteOnce (the volume can only be mounted by a single pod for read and write).
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 1Gi
---
apiVersion: v1                                                  # v1 (core Kubernetes resource).
kind: ConfigMap                                                 # ConfigMap, a Kubernetes object for storing configuration data.
metadata:
  name: nginx-config
  namespace: production
data:                                                           # Contains the nginx.conf file that configures Nginx to listen on port 80 and proxy requests to localhost.
  nginx.conf: |
    server {
      listen 80;
      location / {
        proxy_pass http://localhost;
      }
    }
---
apiVersion: v1
kind: Secret                                                   # Secret, a Kubernetes object for storing sensitive data.
metadata:
  name: nginx-secrets
  namespace: production
type: Opaque
data:                                                         # Stores the base64-encoded string secret.
  my-secret: c2VjcmV0Cg== # Base64 encoded 'secret'
---
apiVersion: policy/v1                                         # policy/v1 (for disruption control).
kind: PodDisruptionBudget                                     # PDB to control voluntary disruptions (e.g., rolling updates).
metadata:
  name: nginx-pdb
  namespace: production
spec:
  minAvailable: 2                                             # Ensures that at least 2 pods are available during disruptions.Helps with HA (high availability).
  selector:
    matchLabels:
      app: nginx
---
apiVersion: autoscaling/v2                   # Specifies the version of the Kubernetes API used.is a newer API version that supports multiple metrics, such as CPU, memory, custom metrics, and external metrics.
kind: HorizontalPodAutoscaler                # Declares the resource type.HorizontalPodAutoscaler is used to automatically scale the number of pods in a deployment (or other scalable resource) based on defined metrics.
metadata:
  name: nginx-hpa                            # The name of the HPA object (used by Kubernetes to identify the HPA).
  namespace: production                      # The HPA is scoped to the production namespace, ensuring it only affects resources in that namespace.
spec:
  scaleTargetRef:                           # Points to the target resource to be scaled.
    apiVersion: apps/v1                     # The API version of the target resource.
    kind: Deployment                        # The type of resource to scale.
    name: nginx-deployment                  # The name of the specific deployment.
  minReplicas: 3                            # The minimum number of pods that should run, even if usage is low.Helps maintain baseline availability or performance.
  maxReplicas: 10                           # The upper limit of pods that can be created.Prevents over-scaling and excessive resource consumption.
  metrics:                                  # List of scaling metrics.
    - type: Resource                        # We're scaling based on a resource usage metric (CPU here).
      resource:                             # The specific resource being tracked.
        name: cpu
        target:                             # We're measuring the percentage of requested CPU being used.
          type: Utilization
          averageUtilization: 80            # The target is 80% of requested CPU across all pods. If CPU usage goes above 80%, more pods will be added. If it stays well below 80%, pods may be scaled down (not below 3 because of minReplicas).
    - type: Resource                        # A second metric, similar to the first but for memory.Kubernetes will now scale based on the higher need: either CPU or memory.
      resource:
        name: memory
        target:
          type: Utilization
          averageUtilization: 80            # Whichever metric hits the threshold first will trigger scaling. For example:If CPU is at 60% but memory is at 85%, the HPA will scale up to try to bring memory usage down to 80%.
---
apiVersion: v1
kind: Service
metadata:
  name: nginx-service
  namespace: production
spec:
  selector:
    app: nginx
  ports:
    - protocol: TCP
      port: 80
      targetPort: 80
  type: ClusterIP
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  namespace: production
  name: nginx-role
rules:
  - apiGroups: [""]
    resources: ["pods"]
    verbs: ["get", "list", "watch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: nginx-role-binding
  namespace: production
subjects:
  - kind: ServiceAccount
    name: nginx-service-account
    namespace: production
roleRef:
  kind: Role
  name: nginx-role
  apiGroup: rbac.authorization.k8s.io
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: nginx-cluster-role
rules:
  - apiGroups: [""]
    resources: ["pods"]
    verbs: ["get", "list", "watch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: nginx-cluster-role-binding
subjects:
  - kind: ServiceAccount
    name: nginx-service-account
    namespace: production
roleRef:
  kind: ClusterRole
  name: nginx-cluster-role
  apiGroup: rbac.authorization.k8s.io
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: nginx-service-account
  namespace: production
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
  namespace: production
  labels:
    app: nginx
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      serviceAccountName: nginx-service-account # Service Account for running the pod
      nodeSelector: 
        disktype: ssd # Node Affinity, ensure the pod runs on nodes with SSD
      tolerations:
        - key: "key1"
          operator: "Equal"
          value: "value1"
          effect: "NoSchedule"
      containers:
        - name: nginx
          image: nginx:1.14.2
          ports:
            - containerPort: 80
          resources:
            requests:
              memory: "512Mi"
              cpu: "500m"
            limits:
              memory: "1Gi"
              cpu: "1"
          livenessProbe:
            httpGet:
              path: /healthz
              port: 80
            initialDelaySeconds: 5
            periodSeconds: 10
          readinessProbe:
            httpGet:
              path: /healthz
              port: 80
            initialDelaySeconds: 5
            periodSeconds: 10
          startupProbe:
            httpGet:
              path: /healthz
              port: 80
            initialDelaySeconds: 10
            periodSeconds: 5





            
# Key Enhancements:
# Namespace: All resources are now under the production namespace for isolation.

# Init Container: Performs any necessary setup before the main nginx container starts.

# Sidecar Container: A simple logging sidecar container that tail logs from nginx.

# Pod Disruption Budget (PDB): Ensures minimal disruption during voluntary disruptions (e.g., rolling updates).

# Resource Requests & Limits: Defined CPU and memory requests and limits to ensure stable performance.

# Horizontal Pod Autoscaler (HPA): Autoscaling based on CPU and memory utilization.

# Persistent Volume Claim (PVC): Ensures persistence for nginx logs.

# ConfigMap: Configures nginx with a custom nginx.conf file.

# Secrets: Example for securely storing sensitive data.

# Probes: Liveness, readiness, and startup probes for robust health checks.

# RBAC: Role, RoleBinding, ClusterRole, and ClusterRoleBinding for fine-grained access control.

# Service Account: Tied to the deployment for managing pod access control.

# Node Affinity: Ensures the pod runs on nodes with SSDs.

# Taints & Tolerations: Allows specific pods to run on nodes with custom taints.

# Service: Exposes the nginx deployment as a service.

# This setup ensures that the nginx deployment is robust, scalable, and properly isolated for a production environment.
