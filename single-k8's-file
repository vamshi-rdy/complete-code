apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
  namespace: production # Added Namespace for isolation
  labels:
    app: nginx
spec:
  replicas: 3
  strategy:                            # ðŸ‘ˆ Added strategy block. You donâ€™t need to set strategy manually unless you want to tune how Pods are updated â€” Kubernetes uses RollingUpdate by default.
    type: RollingUpdate                # Tells Kubernetes to use a rolling update strategy (default).
    rollingUpdate:
      maxSurge: 1                      #  Allows one extra Pod to be created (beyond desired replicas) during the update.You can set maxSurge and maxUnavailable as percentages as well:maxSurge: 25%,maxUnavailable: 25%.
      maxUnavailable: 1                #  Allows one Pod to be unavailable during the update.
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      serviceAccountName: nginx-service-account # Service Account for running the pod   # Defines the pod's configuration.
      initContainers: # Init container for pre-deployment tasks. Defines an initialization container that runs before the main nginx container starts.
        - name: init-container  
          image: busybox:1.32                                              # Uses busybox:1.32 for running a simple shell command.
          command: ["sh", "-c", "echo 'Initializing nginx pod...'"]        # Runs a shell command to print an initialization message.
          volumeMounts:                                                    # Mounts a volume (config-volume) to /etc/nginx/config in the init container, which could be useful for configuration-related tasks.
            - name: config-volume
              mountPath: /etc/nginx/config
      containers:                                                          # The main containers for the pod.
        - name: nginx                                                      # The container name is nginx.
          image: nginx:1.14.2                                              # Uses the nginx:1.14.2 image.
          ports:                                                           # Exposes port 80 on the container.
            - containerPort: 80
          resources:                                                       # Specifies resource requests and limits for the container.
            requests:                                                      # Minimum resources required for the container (512Mi of memory and 500m CPU).
              memory: "512Mi"
              cpu: "500m"
            limits:                                                        # Maximum resources the container can consume (1Gi of memory and 1 CPU).
              memory: "1Gi"
              cpu: "1"
          livenessProbe:                                                   # A health check to determine if the container is still running and healthy.
            httpGet:                                                       # Sends an HTTP GET request to /healthz on port 80.
              path: /healthz                                               
              port: 80
            initialDelaySeconds: 5                                         # Waits for 5 seconds before starting the probe.
            periodSeconds: 10                                              # Runs the probe every 10 seconds.
          readinessProbe:                                                  # Ensures that the container is ready to serve traffic. Similar to the liveness probe, but used to determine if the container is ready.
            httpGet:
              path: /healthz
              port: 80
            initialDelaySeconds: 5                                        # Waits for 5 seconds before starting the probe.
            periodSeconds: 10                                             # Runs the probe every 10 seconds.
          startupProbe:                                                   # Ensures the container has started successfully before performing liveness or readiness checks.
            httpGet:
              path: /healthz
              port: 80
            initialDelaySeconds: 10                                       # Waits for 10 seconds before starting the probe.
            periodSeconds: 5                                              # Runs the probe every 5 seconds.
      sidecarContainers:                       # Sidecar container for additional functionality (e.g., logging, monitoring) .Adds a sidecar container that runs alongside the main nginx container.
        - name: sidecar-logging       
          image: busybox                                                  # Uses busybox to run a shell command.
          command: ["sh", "-c", "tail -f /var/log/nginx/access.log"]      # Tails the nginx access log in real-time (tail -f).
          volumeMounts:                                                   # Mounts a volume (nginx-log-volume) to /var/log/nginx for accessing logs.
            - name: nginx-log-volume
              mountPath: /var/log/nginx
      volumes:                                                            # Defines volumes to be used by the containers.
        - name: config-volume
          configMap:                                                       # Mounts a ConfigMap called nginx-config to provide the Nginx configuration.
            name: nginx-config
        - name: nginx-log-volume                                           # Uses a Persistent Volume Claim (nginx-pvc) for persistent storage of logs.
          persistentVolumeClaim:
            claimName: nginx-pvc
---
apiVersion: v1                                                    # v1, indicating it's a core Kubernetes API resource.
kind: PersistentVolumeClaim
metadata:                                                         # Defines the nginx-pvc claim in the production namespace.
  name: nginx-pvc
  namespace: production
spec:                                                            # Requests a persistent volume of 1Gi, with access mode ReadWriteOnce (the volume can only be mounted by a single pod for read and write).
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 1Gi
---
apiVersion: v1                                                  # v1 (core Kubernetes resource).
kind: ConfigMap                                                 # ConfigMap, a Kubernetes object for storing configuration data.
metadata:
  name: nginx-config
  namespace: production
data:                                                           # Contains the nginx.conf file that configures Nginx to listen on port 80 and proxy requests to localhost.
  nginx.conf: |
    server {
      listen 80;
      location / {
        proxy_pass http://localhost;
      }
    }
---
apiVersion: v1
kind: Secret                                                   # Secret, a Kubernetes object for storing sensitive data.
metadata:
  name: nginx-secrets
  namespace: production
type: Opaque
data:                                                         # Stores the base64-encoded string secret.
  my-secret: c2VjcmV0Cg== # Base64 encoded 'secret'
---
apiVersion: policy/v1                                         # policy/v1 (for disruption control).
kind: PodDisruptionBudget                                     # PDB to control voluntary disruptions (e.g., rolling updates).
metadata:
  name: nginx-pdb
  namespace: production
spec:
  minAvailable: 2                                             # Ensures that at least 2 pods are available during disruptions.Helps with HA (high availability).
  selector:
    matchLabels:
      app: nginx
---
apiVersion: autoscaling/v2                   # Specifies the version of the Kubernetes API used.is a newer API version that supports multiple metrics, such as CPU, memory, custom metrics, and external metrics.
kind: HorizontalPodAutoscaler                # Declares the resource type.HorizontalPodAutoscaler is used to automatically scale the number of pods in a deployment (or other scalable resource) based on defined metrics.
metadata:
  name: nginx-hpa                            # The name of the HPA object (used by Kubernetes to identify the HPA).
  namespace: production                      # The HPA is scoped to the production namespace, ensuring it only affects resources in that namespace.
spec:
  scaleTargetRef:                           # Points to the target resource to be scaled.
    apiVersion: apps/v1                     # The API version of the target resource.
    kind: Deployment                        # The type of resource to scale.
    name: nginx-deployment                  # The name of the specific deployment.
  minReplicas: 3                            # The minimum number of pods that should run, even if usage is low.Helps maintain baseline availability or performance.
  maxReplicas: 10                           # The upper limit of pods that can be created.Prevents over-scaling and excessive resource consumption.
  metrics:                                  # List of scaling metrics.
    - type: Resource                        # We're scaling based on a resource usage metric (CPU here).
      resource:                             # The specific resource being tracked.
        name: cpu
        target:                             # We're measuring the percentage of requested CPU being used.
          type: Utilization
          averageUtilization: 80            # The target is 80% of requested CPU across all pods. If CPU usage goes above 80%, more pods will be added. If it stays well below 80%, pods may be scaled down (not below 3 because of minReplicas).
    - type: Resource                        # A second metric, similar to the first but for memory.Kubernetes will now scale based on the higher need: either CPU or memory.
      resource:
        name: memory
        target:
          type: Utilization
          averageUtilization: 80            # Whichever metric hits the threshold first will trigger scaling. For example:If CPU is at 60% but memory is at 85%, the HPA will scale up to try to bring memory usage down to 80%.
---
apiVersion: v1                            # This specifies the API version used for the resource, in this case, it's a Service, which uses the v1 API version.
kind: Service                             # The kind of resource is a Kubernetes service.
metadata:                                 # Contains metadata about the service
  name: nginx-service                     # The name of the service is nginx-service.
  namespace: production                   # This service will exist within the production namespace.
spec:                                     # Specifies the configuration of the service:
  selector:                               # The service will route traffic to pods with the label app: nginx.
    app: nginx
  ports:                                  # This section defines the ports that the service will expose:
    - protocol: TCP                       # The service will expose TCP port 80, and it will forward that to port 80 on the pods.
      port: 80
      targetPort: 80
  type: ClusterIP                         # This service is of type ClusterIP, which means it can only be accessed internally within the Kubernetes cluster.
---
apiVersion: rbac.authorization.k8s.io/v1               # Specifies the API version for Role-based Access Control (RBAC) resources.
kind: Role                                             # The kind of resource is a Role, which defines permissions within a specific namespace (production).
metadata:
  namespace: production                                # The role will be created in the production namespace.
  name: nginx-role                                     #  The role is named nginx-role.
rules:                                                 # Defines the permissions associated with this role:
  - apiGroups: [""]                                    # This targets the core API group, which includes resources like pods.
    resources: ["pods"]                                # The role grants permissions on the pods resource.
    verbs: ["get", "list", "watch"]                    # The allowed actions (verbs) on pods are get, list, and watch. This means the role can read information about pods but cannot modify them.
---
apiVersion: rbac.authorization.k8s.io/v1               # The API version for RBAC resources.
kind: RoleBinding                                      # A RoleBinding grants the permissions defined in a Role to a user or service account.
metadata:
  name: nginx-role-binding
  namespace: production
subjects:                                             #  This section lists the entities (like users or service accounts) that will be granted the permissions from the role:
  - kind: ServiceAccount                              # The subject is a ServiceAccount named nginx-service-account in the production namespace.
    name: nginx-service-account
    namespace: production
roleRef:                                             # Refers to the Role that defines the permissions:
  kind: Role                                         # Refers to the role type
  name: nginx-role                                   # The role being referenced.
  apiGroup: rbac.authorization.k8s.io                # Specifies the API group for RBAC.
---
apiVersion: rbac.authorization.k8s.io/v1             # The API version for RBAC resources.
kind: ClusterRole               # A Cluster role is similar to a Role but applies across the entire k8's cluster (not limited to specific namespace)
metadata:
  name: nginx-cluster-role      # The name of the ClusterRole is nginx-cluster-role.
rules:
  - apiGroups: [""]                            # Specifies the permissions for the ClusterRole:
    resources: ["pods"]                        # Permissions are granted on the pods resource.
    verbs: ["get", "list", "watch"]            # These verbs allow reading information about pods. 
---
apiVersion: rbac.authorization.k8s.io/v1       # The API version for RBAC resources.
kind: ClusterRoleBinding                       # A ClusterRoleBinding binds a ClusterRole to a subject, such as a service account.
metadata:
  name: nginx-cluster-role-binding             # The name of the ClusterRoleBinding is nginx-cluster-role-binding.
subjects:                                      # The subject receiving the ClusterRole permissions:
  - kind: ServiceAccount                       # Referring to the service account named nginx-service-account in the production namespace.
    name: nginx-service-account
    namespace: production
roleRef:                                       # Refers to the ClusterRole being granted:
  kind: ClusterRole                            # Refers to the ClusterRole type.
  name: nginx-cluster-role                     # The name of the ClusterRole being referenced.
  apiGroup: rbac.authorization.k8s.io
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: nginx-service-account
  namespace: production
---
apiVersion: apps/v1
kind: Deployment          # A Kubernetes Deployment is used to manage a set of replicated pods.
metadata:
  name: nginx-deployment    
  namespace: production    # The deployment is created in the production namespace.
  labels:                  # The deployment has the label app: nginx, which is used for identifying resources related to the nginx application.
    app: nginx
spec:                      # The spec under the Pod template defines how each Pod should behave.
  replicas: 3              # The deployment will maintain 3 replicas of the nginx pod.
  selector:                # The deployment selects pods with the label app: nginx.
    matchLabels:
      app: nginx
  template:            # Defines the pod template:
    metadata:
      labels:
        app: nginx
    spec:
      serviceAccountName: nginx-service-account         # Service Account for running the pod. The service account nginx-service-account is used by the pods in the deployment.
      nodeSelector:                                     # Ensures that the pods run on nodes with a label `disktype:
        disktype: ssd # Node Affinity, ensure the pod runs on nodes with SSD
      tolerations:                                      # Allows the Pod to be scheduled on nodes tainted with key1=value1:NoSchedule.Without this, the Pod would be unschedulable on such nodes
        - key: "key1"
          operator: "Equal"
          value: "value1"
          effect: "NoSchedule"
      containers:                                     # Container runs nginx:1.14.2 and listens on port 80.
        - name: nginx
          image: nginx:1.14.2
          ports:
            - containerPort: 80
          resources:                    # Specifies resource requests and limits to help with scheduling and quota enforcement.
            requests:
              memory: "512Mi"
              cpu: "500m"
            limits:
              memory: "1Gi"
              cpu: "1"
          livenessProbe:                # Checks if the app is still running. Kills and restarts it if it fails.
            httpGet:                    # Type of probe.Specifies that the liveness probe will perform an HTTP GET request to check if the app is healthy.Other types could be:exec: Run a command inside the container,tcpSocket: Try connecting to a TCP port.
              path: /healthz            # URL path to probe.The HTTP request will be sent to the path /healthz of the container's web server.The container must serve this endpoint and return a 2xx status code to be considered healthy.
              port: 80                  # The probe will connect to port 80 on the container to send the HTTP request.This should match a port exposed by the container.
            initialDelaySeconds: 5      # Wait before first probe.Kubernetes waits 5 seconds after the container starts before performing the first liveness check.This gives the application time to start up.
            periodSeconds: 10           # Frequency of checks.Kubernetes will run the probe every 10 seconds after the initial delay.If the probe fails too many times consecutively (default: 3), the container is restarted.
          readinessProbe:               # Determines when the container is ready to accept traffic.
            httpGet:
              path: /healthz
              port: 80
            initialDelaySeconds: 5
            periodSeconds: 10
          startupProbe:                 # Used during startup. Prevents premature liveness probe failures.
            httpGet:
              path: /healthz
              port: 80
            initialDelaySeconds: 10
            periodSeconds: 5





            
# Key Enhancements:
# Namespace: All resources are now under the production namespace for isolation.

# Init Container: Performs any necessary setup before the main nginx container starts.

# Sidecar Container: A simple logging sidecar container that tail logs from nginx.

# Pod Disruption Budget (PDB): Ensures minimal disruption during voluntary disruptions (e.g., rolling updates).

# Resource Requests & Limits: Defined CPU and memory requests and limits to ensure stable performance.

# Horizontal Pod Autoscaler (HPA): Autoscaling based on CPU and memory utilization.

# Persistent Volume Claim (PVC): Ensures persistence for nginx logs.

# ConfigMap: Configures nginx with a custom nginx.conf file.

# Secrets: Example for securely storing sensitive data.

# Probes: Liveness, readiness, and startup probes for robust health checks.

# RBAC: Role, RoleBinding, ClusterRole, and ClusterRoleBinding for fine-grained access control.

# Service Account: Tied to the deployment for managing pod access control.

# Node Affinity: Ensures the pod runs on nodes with SSDs.

# Taints & Tolerations: Allows specific pods to run on nodes with custom taints.

# Service: Exposes the nginx deployment as a service.

# This setup ensures that the nginx deployment is robust, scalable, and properly isolated for a production environment.


Summary of What This File Does:
Creates a Service to expose the NGINX pods internally.

Defines RBAC roles and bindings for a service account.

Sets up a Deployment of NGINX pods with resource limits, health checks, node selection, and taint tolerations.

Uses Startup, Liveness, and Readiness probes for reliability.

Separates access control using Role (namespace level) and ClusterRole (cluster-wide).

Let me know if you want this visualized, simplified, or converted into Helm or Kustomize format.


Example Use Case:
Imagine your NGINX or web app can crash silently (itâ€™s running, but non-functional). The liveness probe helps automatically recover from this situation by restarting the broken container.
